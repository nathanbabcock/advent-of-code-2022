# Day 1

## IN:

```js
;`1000
2000
3000

4000

5000
6000

7000
8000
9000

10000`
```

## STEP 1: `split`

```js
;[
  `1000
2000
3000`,
  // ...
]
```

## STEP 2: `map(split)`

```js
;[
  ['1000', '2000', '3000'],
  // ...
]
```

## STEP 3: `map(map(parse))`

```js
;[
  [1000, 2000, 3000],
  [4000],
  [5000, 6000],
  // ...
]
```

## STEP 4: `map(sum)`

```js
;[
  6000, 4000, 11000,
  // ...
]
```

## OUT: `max`

```js
24000
```

## OPS: `split`, `parse`, `sum`, `max`, `map(op)`

- `split(string, string) -> array<string>`
- `parse(string) -> number`
- `sum(array<number>) -> number`
- `max(array<number>) -> number`
- `map(array<t>, op<array<t>, s>) -> array<s>`

## CHALLENGE: Given input, output, and all intermediate steps, solve for the OPS used between each step.

## METHOD: Type signature combinatorics

- first input is string
- ... ops that take string as input...
- ... ? ...
- ... ops that produce number as output...
- final output is number

## BRANCHING TREE SEARCH -- execution trace

- Either `split` or `parse`
  - `parse` -> `NaN` (dead end)
  - `split` -> `array<string>` (step 1); `// choice of bound parameter to split by`
    - `map(parse)` => `array<number | NaN>`
      - `max` -> `NaN`
      - `sum` -> `NaN`
    - `map(split)` => `array<array<string>>` (step 2) `// choice of bound parameter to split by`
      - `map(map(split))` -> `array<array<array<string>>>` ... (rabbit hole/infinite recursion)
      - `map(map(parse))` -> `array<array<number>>` (step 3)
        - `map(max)` -> `array<number>`
          - `max` -> `number` (wrong answer)
          - `sum` -> `number` (wrong answer)
        - `map(sum)` -> `array<number>` (step 4)
          - `map(sum)` -> `number` (wrong answer)
          - `map(max)` -> `number` (CORRECT ANSWER)

## NOTES

- Breadth first search (shallowest possible)
- Constrained by type signature
  - Generics ~~complicate things~~ expand range of possibilities
  - Analagous to valid move generation in chess AI
- Library of OPS should be as narrow & constrained as possible to solve the problem
  - Attempt to solve the problem with a constrained subset of OPS and grow it over time?
- Choice of free parameters
  - `split` second parameter, 2 times
  - `map` op parameter, 4 times (including nesting)
- _Any_ pattern in the data is a sign that you are on the right track -- the simpler the pattern (e.g. less composition of simple OPS) the better.
  - This can be applied in both directions (prev -> current AND current -> next)
- Models problems as a linear chain of pure functional transformations
  - ...which could also (likely) be expressed as bidirectional lenses

## KEY PROBLEMS

- Inferring the char parameter for `split`
  - Characters which appear in input? More often -> better choice?
  - Detect the pattern between occurences of the split char & length (+1) of the resulting array?
    -> Detecting simple patterns & symmetries as an "intuition" to drive the search direction
    -> Learning heuristics for each op and how/when to use it
    -> Reasoning about assumptions (e.g. param of `split` must appear in input string)
- Template-mapping parts of input to parts of output, and then filling gaps
  -> in the case of `split`, all the gaps contain the `split` char param (!)
- Exploring off-by-one errors and some sense of "distance" from the correct answer
- Detecting dead-ends and infinite recursion (automatically solved by searching breadth-first?)

## OPEN QUESTIONS

- How does the algorithm scale as the number (and generality) of OPS increases?
- How does the algorithm scale as the size of the INPUT increases?
- How many INTERMEDIATE steps are needed to guide the search? In this simple example, is it possible to go straight from input -> output?
  - Can this be made collaborative w/ the programmer?
- Can some of the intermediate steps be parsed from the **natural language description** of the problem?

## PHILOSOPHY

Simple breadth-first AST search guided by [heuristics, hunches, theories, assumptions, experience, symmetries, harmonies, rythyms, and patterns].

Simple breadth-first AST search guided by **INTUITION**.
